// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const createSetting = `-- name: CreateSetting :execresult
INSERT INTO settings (
    user_id, material_id, laser_type, wattage, operation_type,
    max_power, min_power, max_power2, min_power2, speed,
    num_passes, z_offset, z_per_pass,
    scan_interval, angle, angle_per_pass,
    cross_hatch, bidir, scan_opt,
    flood_fill, auto_rotate, overscan, overscan_percent,
    frequency, wobble_enable, use_dot_correction,
    kerf, run_blower,
    layer_name, layer_subname,
    priority, tab_count, tab_count_max,
    notes
) VALUES (
    ?, ?, ?, ?, ?,
    ?, ?, ?, ?, ?,
    ?, ?, ?,
    ?, ?, ?,
    ?, ?, ?,
    ?, ?, ?, ?,
    ?, ?, ?,
    ?, ?,
    ?, ?,
    ?, ?, ?,
    ?
)
`

type CreateSettingParams struct {
	UserID           int32
	MaterialID       int32
	LaserType        SettingsLaserType
	Wattage          int32
	OperationType    SettingsOperationType
	MaxPower         string
	MinPower         string
	MaxPower2        sql.NullString
	MinPower2        sql.NullString
	Speed            string
	NumPasses        int32
	ZOffset          sql.NullString
	ZPerPass         sql.NullString
	ScanInterval     sql.NullString
	Angle            sql.NullString
	AnglePerPass     sql.NullString
	CrossHatch       bool
	Bidir            bool
	ScanOpt          sql.NullString
	FloodFill        bool
	AutoRotate       bool
	Overscan         sql.NullString
	OverscanPercent  sql.NullString
	Frequency        sql.NullString
	WobbleEnable     sql.NullBool
	UseDotCorrection sql.NullBool
	Kerf             sql.NullString
	RunBlower        sql.NullBool
	LayerName        sql.NullString
	LayerSubname     sql.NullString
	Priority         sql.NullInt32
	TabCount         sql.NullInt32
	TabCountMax      sql.NullInt32
	Notes            sql.NullString
}

func (q *Queries) CreateSetting(ctx context.Context, arg CreateSettingParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createSetting,
		arg.UserID,
		arg.MaterialID,
		arg.LaserType,
		arg.Wattage,
		arg.OperationType,
		arg.MaxPower,
		arg.MinPower,
		arg.MaxPower2,
		arg.MinPower2,
		arg.Speed,
		arg.NumPasses,
		arg.ZOffset,
		arg.ZPerPass,
		arg.ScanInterval,
		arg.Angle,
		arg.AnglePerPass,
		arg.CrossHatch,
		arg.Bidir,
		arg.ScanOpt,
		arg.FloodFill,
		arg.AutoRotate,
		arg.Overscan,
		arg.OverscanPercent,
		arg.Frequency,
		arg.WobbleEnable,
		arg.UseDotCorrection,
		arg.Kerf,
		arg.RunBlower,
		arg.LayerName,
		arg.LayerSubname,
		arg.Priority,
		arg.TabCount,
		arg.TabCountMax,
		arg.Notes,
	)
}

const createUser = `-- name: CreateUser :execresult
INSERT INTO users (username, email, password_hash, display_name)
VALUES (?, ?, ?, ?)
`

type CreateUserParams struct {
	Username     string
	Email        string
	PasswordHash string
	DisplayName  sql.NullString
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createUser,
		arg.Username,
		arg.Email,
		arg.PasswordHash,
		arg.DisplayName,
	)
}

const deleteSetting = `-- name: DeleteSetting :exec
DELETE FROM settings
WHERE id = ? AND user_id = ?
`

type DeleteSettingParams struct {
	ID     int32
	UserID int32
}

func (q *Queries) DeleteSetting(ctx context.Context, arg DeleteSettingParams) error {
	_, err := q.db.ExecContext(ctx, deleteSetting, arg.ID, arg.UserID)
	return err
}

const deleteVote = `-- name: DeleteVote :exec
DELETE FROM votes
WHERE user_id = ? AND setting_id = ?
`

type DeleteVoteParams struct {
	UserID    int32
	SettingID int32
}

func (q *Queries) DeleteVote(ctx context.Context, arg DeleteVoteParams) error {
	_, err := q.db.ExecContext(ctx, deleteVote, arg.UserID, arg.SettingID)
	return err
}

const getAliasesByMaterial = `-- name: GetAliasesByMaterial :many
SELECT id, material_id, alias
FROM material_aliases
WHERE material_id = ?
ORDER BY alias
`

func (q *Queries) GetAliasesByMaterial(ctx context.Context, materialID int32) ([]MaterialAlias, error) {
	rows, err := q.db.QueryContext(ctx, getAliasesByMaterial, materialID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MaterialAlias
	for rows.Next() {
		var i MaterialAlias
		if err := rows.Scan(&i.ID, &i.MaterialID, &i.Alias); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCategories = `-- name: GetAllCategories :many

SELECT id, name
FROM material_categories
ORDER BY name
`

// =====================
// MATERIAL CATEGORIES
// =====================
func (q *Queries) GetAllCategories(ctx context.Context) ([]MaterialCategory, error) {
	rows, err := q.db.QueryContext(ctx, getAllCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MaterialCategory
	for rows.Next() {
		var i MaterialCategory
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllMaterials = `-- name: GetAllMaterials :many

SELECT m.id, m.category_id, m.name, m.slug,
       c.name as category_name
FROM materials m
JOIN material_categories c ON m.category_id = c.id
ORDER BY c.name, m.name
`

type GetAllMaterialsRow struct {
	ID           int32
	CategoryID   int32
	Name         string
	Slug         string
	CategoryName string
}

// =====================
// MATERIALS
// =====================
func (q *Queries) GetAllMaterials(ctx context.Context) ([]GetAllMaterialsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllMaterials)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllMaterialsRow
	for rows.Next() {
		var i GetAllMaterialsRow
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMaterialByID = `-- name: GetMaterialByID :one
SELECT m.id, m.category_id, m.name, m.slug,
       c.name as category_name
FROM materials m
JOIN material_categories c ON m.category_id = c.id
WHERE m.id = ?
`

type GetMaterialByIDRow struct {
	ID           int32
	CategoryID   int32
	Name         string
	Slug         string
	CategoryName string
}

func (q *Queries) GetMaterialByID(ctx context.Context, id int32) (GetMaterialByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getMaterialByID, id)
	var i GetMaterialByIDRow
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.CategoryName,
	)
	return i, err
}

const getMaterialsByCategory = `-- name: GetMaterialsByCategory :many
SELECT id, category_id, name, slug
FROM materials
WHERE category_id = ?
ORDER BY name
`

func (q *Queries) GetMaterialsByCategory(ctx context.Context, categoryID int32) ([]Material, error) {
	rows, err := q.db.QueryContext(ctx, getMaterialsByCategory, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Material
	for rows.Next() {
		var i Material
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSettingByID = `-- name: GetSettingByID :one

SELECT s.id, s.user_id, s.material_id,
       s.laser_type, s.wattage, s.operation_type,
       s.max_power, s.min_power, s.max_power2, s.min_power2, s.speed,
       s.num_passes, s.z_offset, s.z_per_pass,
       s.scan_interval, s.angle, s.angle_per_pass,
       s.cross_hatch, s.bidir, s.scan_opt,
       s.flood_fill, s.auto_rotate, s.overscan, s.overscan_percent,
       s.frequency, s.wobble_enable, s.use_dot_correction,
       s.kerf, s.run_blower,
       s.layer_name, s.layer_subname,
       s.priority, s.tab_count, s.tab_count_max,
       s.notes, s.created_at, s.updated_at,
       u.username, u.display_name,
       mat.name as material_name, mc.name as category_name,
       COALESCE(SUM(v.value), 0) as vote_score,
       COUNT(v.id) as vote_count
FROM settings s
JOIN users u ON s.user_id = u.id
JOIN materials mat ON s.material_id = mat.id
JOIN material_categories mc ON mat.category_id = mc.id
LEFT JOIN votes v ON v.setting_id = s.id
WHERE s.id = ?
GROUP BY s.id
`

type GetSettingByIDRow struct {
	ID               int32
	UserID           int32
	MaterialID       int32
	LaserType        SettingsLaserType
	Wattage          int32
	OperationType    SettingsOperationType
	MaxPower         string
	MinPower         string
	MaxPower2        sql.NullString
	MinPower2        sql.NullString
	Speed            string
	NumPasses        int32
	ZOffset          sql.NullString
	ZPerPass         sql.NullString
	ScanInterval     sql.NullString
	Angle            sql.NullString
	AnglePerPass     sql.NullString
	CrossHatch       bool
	Bidir            bool
	ScanOpt          sql.NullString
	FloodFill        bool
	AutoRotate       bool
	Overscan         sql.NullString
	OverscanPercent  sql.NullString
	Frequency        sql.NullString
	WobbleEnable     sql.NullBool
	UseDotCorrection sql.NullBool
	Kerf             sql.NullString
	RunBlower        sql.NullBool
	LayerName        sql.NullString
	LayerSubname     sql.NullString
	Priority         sql.NullInt32
	TabCount         sql.NullInt32
	TabCountMax      sql.NullInt32
	Notes            sql.NullString
	CreatedAt        sql.NullTime
	UpdatedAt        sql.NullTime
	Username         string
	DisplayName      sql.NullString
	MaterialName     string
	CategoryName     string
	VoteScore        interface{}
	VoteCount        int64
}

// =====================
// SETTINGS
// =====================
func (q *Queries) GetSettingByID(ctx context.Context, id int32) (GetSettingByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getSettingByID, id)
	var i GetSettingByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MaterialID,
		&i.LaserType,
		&i.Wattage,
		&i.OperationType,
		&i.MaxPower,
		&i.MinPower,
		&i.MaxPower2,
		&i.MinPower2,
		&i.Speed,
		&i.NumPasses,
		&i.ZOffset,
		&i.ZPerPass,
		&i.ScanInterval,
		&i.Angle,
		&i.AnglePerPass,
		&i.CrossHatch,
		&i.Bidir,
		&i.ScanOpt,
		&i.FloodFill,
		&i.AutoRotate,
		&i.Overscan,
		&i.OverscanPercent,
		&i.Frequency,
		&i.WobbleEnable,
		&i.UseDotCorrection,
		&i.Kerf,
		&i.RunBlower,
		&i.LayerName,
		&i.LayerSubname,
		&i.Priority,
		&i.TabCount,
		&i.TabCountMax,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Username,
		&i.DisplayName,
		&i.MaterialName,
		&i.CategoryName,
		&i.VoteScore,
		&i.VoteCount,
	)
	return i, err
}

const getTopSettings = `-- name: GetTopSettings :many
SELECT s.id, s.user_id, s.material_id,
       s.laser_type, s.wattage, s.operation_type,
       s.max_power, s.min_power, s.speed,
       s.num_passes, s.scan_interval, s.frequency,
       s.cross_hatch, s.angle, s.angle_per_pass,
       s.notes, s.created_at,
       u.username, u.display_name,
       mat.name as material_name, mc.name as category_name,
       COALESCE(SUM(v.value), 0) as vote_score,
       COUNT(v.id) as vote_count
FROM settings s
JOIN users u ON s.user_id = u.id
JOIN materials mat ON s.material_id = mat.id
JOIN material_categories mc ON mat.category_id = mc.id
LEFT JOIN votes v ON v.setting_id = s.id
GROUP BY s.id
ORDER BY vote_score DESC
LIMIT 20
`

type GetTopSettingsRow struct {
	ID            int32
	UserID        int32
	MaterialID    int32
	LaserType     SettingsLaserType
	Wattage       int32
	OperationType SettingsOperationType
	MaxPower      string
	MinPower      string
	Speed         string
	NumPasses     int32
	ScanInterval  sql.NullString
	Frequency     sql.NullString
	CrossHatch    bool
	Angle         sql.NullString
	AnglePerPass  sql.NullString
	Notes         sql.NullString
	CreatedAt     sql.NullTime
	Username      string
	DisplayName   sql.NullString
	MaterialName  string
	CategoryName  string
	VoteScore     interface{}
	VoteCount     int64
}

func (q *Queries) GetTopSettings(ctx context.Context) ([]GetTopSettingsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopSettings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopSettingsRow
	for rows.Next() {
		var i GetTopSettingsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MaterialID,
			&i.LaserType,
			&i.Wattage,
			&i.OperationType,
			&i.MaxPower,
			&i.MinPower,
			&i.Speed,
			&i.NumPasses,
			&i.ScanInterval,
			&i.Frequency,
			&i.CrossHatch,
			&i.Angle,
			&i.AnglePerPass,
			&i.Notes,
			&i.CreatedAt,
			&i.Username,
			&i.DisplayName,
			&i.MaterialName,
			&i.CategoryName,
			&i.VoteScore,
			&i.VoteCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, email, password_hash, display_name, created_at
FROM users
WHERE email = ?
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.DisplayName,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one

SELECT id, username, email, password_hash, display_name, created_at
FROM users
WHERE id = ?
`

// =====================
// USERS
// =====================
func (q *Queries) GetUserByID(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.DisplayName,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, email, password_hash, display_name, created_at
FROM users
WHERE username = ?
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.DisplayName,
		&i.CreatedAt,
	)
	return i, err
}

const getUserSettings = `-- name: GetUserSettings :many
SELECT s.id, s.user_id, s.material_id,
       s.laser_type, s.wattage, s.operation_type,
       s.max_power, s.min_power, s.speed,
       s.num_passes, s.scan_interval, s.frequency,
       s.cross_hatch, s.angle, s.angle_per_pass,
       s.notes, s.created_at, s.updated_at,
       mat.name as material_name, mc.name as category_name,
       COALESCE(SUM(v.value), 0) as vote_score,
       COUNT(v.id) as vote_count
FROM settings s
JOIN materials mat ON s.material_id = mat.id
JOIN material_categories mc ON mat.category_id = mc.id
LEFT JOIN votes v ON v.setting_id = s.id
WHERE s.user_id = ?
GROUP BY s.id
ORDER BY s.created_at DESC
`

type GetUserSettingsRow struct {
	ID            int32
	UserID        int32
	MaterialID    int32
	LaserType     SettingsLaserType
	Wattage       int32
	OperationType SettingsOperationType
	MaxPower      string
	MinPower      string
	Speed         string
	NumPasses     int32
	ScanInterval  sql.NullString
	Frequency     sql.NullString
	CrossHatch    bool
	Angle         sql.NullString
	AnglePerPass  sql.NullString
	Notes         sql.NullString
	CreatedAt     sql.NullTime
	UpdatedAt     sql.NullTime
	MaterialName  string
	CategoryName  string
	VoteScore     interface{}
	VoteCount     int64
}

func (q *Queries) GetUserSettings(ctx context.Context, userID int32) ([]GetUserSettingsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserSettings, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserSettingsRow
	for rows.Next() {
		var i GetUserSettingsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MaterialID,
			&i.LaserType,
			&i.Wattage,
			&i.OperationType,
			&i.MaxPower,
			&i.MinPower,
			&i.Speed,
			&i.NumPasses,
			&i.ScanInterval,
			&i.Frequency,
			&i.CrossHatch,
			&i.Angle,
			&i.AnglePerPass,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MaterialName,
			&i.CategoryName,
			&i.VoteScore,
			&i.VoteCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserVoteForSetting = `-- name: GetUserVoteForSetting :one

SELECT id, user_id, setting_id, value, created_at
FROM votes
WHERE user_id = ? AND setting_id = ?
`

type GetUserVoteForSettingParams struct {
	UserID    int32
	SettingID int32
}

// =====================
// VOTES
// =====================
func (q *Queries) GetUserVoteForSetting(ctx context.Context, arg GetUserVoteForSettingParams) (Vote, error) {
	row := q.db.QueryRowContext(ctx, getUserVoteForSetting, arg.UserID, arg.SettingID)
	var i Vote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SettingID,
		&i.Value,
		&i.CreatedAt,
	)
	return i, err
}

const getVoteScore = `-- name: GetVoteScore :one
SELECT COALESCE(SUM(value), 0) as score, COUNT(id) as total
FROM votes
WHERE setting_id = ?
`

type GetVoteScoreRow struct {
	Score interface{}
	Total int64
}

func (q *Queries) GetVoteScore(ctx context.Context, settingID int32) (GetVoteScoreRow, error) {
	row := q.db.QueryRowContext(ctx, getVoteScore, settingID)
	var i GetVoteScoreRow
	err := row.Scan(&i.Score, &i.Total)
	return i, err
}

const searchMaterials = `-- name: SearchMaterials :many
SELECT m.id, m.category_id, m.name, m.slug,
       c.name as category_name
FROM materials m
JOIN material_categories c ON m.category_id = c.id
WHERE m.name LIKE CONCAT('%', ?, '%')
   OR m.slug LIKE CONCAT('%', ?, '%')
ORDER BY m.name
LIMIT 20
`

type SearchMaterialsParams struct {
	CONCAT   interface{}
	CONCAT_2 interface{}
}

type SearchMaterialsRow struct {
	ID           int32
	CategoryID   int32
	Name         string
	Slug         string
	CategoryName string
}

func (q *Queries) SearchMaterials(ctx context.Context, arg SearchMaterialsParams) ([]SearchMaterialsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchMaterials, arg.CONCAT, arg.CONCAT_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchMaterialsRow
	for rows.Next() {
		var i SearchMaterialsRow
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchMaterialsWithAliases = `-- name: SearchMaterialsWithAliases :many
SELECT DISTINCT m.id, m.category_id, m.name, m.slug,
       c.name as category_name
FROM materials m
JOIN material_categories c ON m.category_id = c.id
LEFT JOIN material_aliases ma ON ma.material_id = m.id
WHERE m.name LIKE CONCAT('%', ?, '%')
   OR m.slug LIKE CONCAT('%', ?, '%')
   OR ma.alias LIKE CONCAT('%', ?, '%')
ORDER BY m.name
LIMIT 20
`

type SearchMaterialsWithAliasesParams struct {
	CONCAT   interface{}
	CONCAT_2 interface{}
	CONCAT_3 interface{}
}

type SearchMaterialsWithAliasesRow struct {
	ID           int32
	CategoryID   int32
	Name         string
	Slug         string
	CategoryName string
}

func (q *Queries) SearchMaterialsWithAliases(ctx context.Context, arg SearchMaterialsWithAliasesParams) ([]SearchMaterialsWithAliasesRow, error) {
	rows, err := q.db.QueryContext(ctx, searchMaterialsWithAliases, arg.CONCAT, arg.CONCAT_2, arg.CONCAT_3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchMaterialsWithAliasesRow
	for rows.Next() {
		var i SearchMaterialsWithAliasesRow
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSettings = `-- name: SearchSettings :many
SELECT s.id, s.user_id, s.material_id,
       s.laser_type, s.wattage, s.operation_type,
       s.max_power, s.min_power, s.speed,
       s.num_passes, s.scan_interval, s.frequency,
       s.cross_hatch, s.angle, s.angle_per_pass,
       s.notes, s.created_at,
       u.username, u.display_name,
       mat.name as material_name, mc.name as category_name,
       COALESCE(SUM(v.value), 0) as vote_score,
       COUNT(v.id) as vote_count
FROM settings s
JOIN users u ON s.user_id = u.id
JOIN materials mat ON s.material_id = mat.id
JOIN material_categories mc ON mat.category_id = mc.id
LEFT JOIN votes v ON v.setting_id = s.id
WHERE (? IS NULL OR s.material_id = ?)
  AND (? IS NULL OR s.laser_type = ?)
  AND (? IS NULL OR s.wattage = ?)
  AND (? IS NULL OR s.operation_type = ?)
  AND (? IS NULL OR s.user_id = ?)
GROUP BY s.id
ORDER BY vote_score DESC, s.created_at DESC
LIMIT 50
`

type SearchSettingsParams struct {
	MaterialID    sql.NullInt32
	LaserType     NullSettingsLaserType
	Wattage       sql.NullInt32
	OperationType NullSettingsOperationType
	UserID        sql.NullInt32
}

type SearchSettingsRow struct {
	ID            int32
	UserID        int32
	MaterialID    int32
	LaserType     SettingsLaserType
	Wattage       int32
	OperationType SettingsOperationType
	MaxPower      string
	MinPower      string
	Speed         string
	NumPasses     int32
	ScanInterval  sql.NullString
	Frequency     sql.NullString
	CrossHatch    bool
	Angle         sql.NullString
	AnglePerPass  sql.NullString
	Notes         sql.NullString
	CreatedAt     sql.NullTime
	Username      string
	DisplayName   sql.NullString
	MaterialName  string
	CategoryName  string
	VoteScore     interface{}
	VoteCount     int64
}

func (q *Queries) SearchSettings(ctx context.Context, arg SearchSettingsParams) ([]SearchSettingsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchSettings,
		arg.MaterialID,
		arg.MaterialID,
		arg.LaserType,
		arg.LaserType,
		arg.Wattage,
		arg.Wattage,
		arg.OperationType,
		arg.OperationType,
		arg.UserID,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchSettingsRow
	for rows.Next() {
		var i SearchSettingsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MaterialID,
			&i.LaserType,
			&i.Wattage,
			&i.OperationType,
			&i.MaxPower,
			&i.MinPower,
			&i.Speed,
			&i.NumPasses,
			&i.ScanInterval,
			&i.Frequency,
			&i.CrossHatch,
			&i.Angle,
			&i.AnglePerPass,
			&i.Notes,
			&i.CreatedAt,
			&i.Username,
			&i.DisplayName,
			&i.MaterialName,
			&i.CategoryName,
			&i.VoteScore,
			&i.VoteCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSetting = `-- name: UpdateSetting :exec
UPDATE settings SET
    max_power = ?, min_power = ?, max_power2 = ?, min_power2 = ?, speed = ?,
    num_passes = ?, z_offset = ?, z_per_pass = ?,
    scan_interval = ?, angle = ?, angle_per_pass = ?,
    cross_hatch = ?, bidir = ?, scan_opt = ?,
    flood_fill = ?, auto_rotate = ?, overscan = ?, overscan_percent = ?,
    frequency = ?, wobble_enable = ?, use_dot_correction = ?,
    kerf = ?, run_blower = ?,
    layer_name = ?, layer_subname = ?,
    priority = ?, tab_count = ?, tab_count_max = ?,
    notes = ?
WHERE id = ? AND user_id = ?
`

type UpdateSettingParams struct {
	MaxPower         string
	MinPower         string
	MaxPower2        sql.NullString
	MinPower2        sql.NullString
	Speed            string
	NumPasses        int32
	ZOffset          sql.NullString
	ZPerPass         sql.NullString
	ScanInterval     sql.NullString
	Angle            sql.NullString
	AnglePerPass     sql.NullString
	CrossHatch       bool
	Bidir            bool
	ScanOpt          sql.NullString
	FloodFill        bool
	AutoRotate       bool
	Overscan         sql.NullString
	OverscanPercent  sql.NullString
	Frequency        sql.NullString
	WobbleEnable     sql.NullBool
	UseDotCorrection sql.NullBool
	Kerf             sql.NullString
	RunBlower        sql.NullBool
	LayerName        sql.NullString
	LayerSubname     sql.NullString
	Priority         sql.NullInt32
	TabCount         sql.NullInt32
	TabCountMax      sql.NullInt32
	Notes            sql.NullString
	ID               int32
	UserID           int32
}

func (q *Queries) UpdateSetting(ctx context.Context, arg UpdateSettingParams) error {
	_, err := q.db.ExecContext(ctx, updateSetting,
		arg.MaxPower,
		arg.MinPower,
		arg.MaxPower2,
		arg.MinPower2,
		arg.Speed,
		arg.NumPasses,
		arg.ZOffset,
		arg.ZPerPass,
		arg.ScanInterval,
		arg.Angle,
		arg.AnglePerPass,
		arg.CrossHatch,
		arg.Bidir,
		arg.ScanOpt,
		arg.FloodFill,
		arg.AutoRotate,
		arg.Overscan,
		arg.OverscanPercent,
		arg.Frequency,
		arg.WobbleEnable,
		arg.UseDotCorrection,
		arg.Kerf,
		arg.RunBlower,
		arg.LayerName,
		arg.LayerSubname,
		arg.Priority,
		arg.TabCount,
		arg.TabCountMax,
		arg.Notes,
		arg.ID,
		arg.UserID,
	)
	return err
}

const upsertVote = `-- name: UpsertVote :exec
INSERT INTO votes (user_id, setting_id, value)
VALUES (?, ?, ?)
ON DUPLICATE KEY UPDATE value = VALUES(value)
`

type UpsertVoteParams struct {
	UserID    int32
	SettingID int32
	Value     int8
}

func (q *Queries) UpsertVote(ctx context.Context, arg UpsertVoteParams) error {
	_, err := q.db.ExecContext(ctx, upsertVote, arg.UserID, arg.SettingID, arg.Value)
	return err
}
