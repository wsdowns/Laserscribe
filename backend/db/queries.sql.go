// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const createSetting = `-- name: CreateSetting :execresult
INSERT INTO settings (user_id, machine_model_id, material_id, operation_id, power, speed, passes, frequency, dpi, notes)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateSettingParams struct {
	UserID         int32
	MachineModelID int32
	MaterialID     int32
	OperationID    int32
	Power          int32
	Speed          int32
	Passes         int32
	Frequency      sql.NullInt32
	Dpi            sql.NullInt32
	Notes          sql.NullString
}

func (q *Queries) CreateSetting(ctx context.Context, arg CreateSettingParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createSetting,
		arg.UserID,
		arg.MachineModelID,
		arg.MaterialID,
		arg.OperationID,
		arg.Power,
		arg.Speed,
		arg.Passes,
		arg.Frequency,
		arg.Dpi,
		arg.Notes,
	)
}

const createUser = `-- name: CreateUser :execresult
INSERT INTO users (username, email, password_hash, display_name)
VALUES (?, ?, ?, ?)
`

type CreateUserParams struct {
	Username     string
	Email        string
	PasswordHash string
	DisplayName  sql.NullString
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createUser,
		arg.Username,
		arg.Email,
		arg.PasswordHash,
		arg.DisplayName,
	)
}

const deleteSetting = `-- name: DeleteSetting :exec
DELETE FROM settings
WHERE id = ? AND user_id = ?
`

type DeleteSettingParams struct {
	ID     int32
	UserID int32
}

func (q *Queries) DeleteSetting(ctx context.Context, arg DeleteSettingParams) error {
	_, err := q.db.ExecContext(ctx, deleteSetting, arg.ID, arg.UserID)
	return err
}

const deleteVote = `-- name: DeleteVote :exec
DELETE FROM votes
WHERE user_id = ? AND setting_id = ?
`

type DeleteVoteParams struct {
	UserID    int32
	SettingID int32
}

func (q *Queries) DeleteVote(ctx context.Context, arg DeleteVoteParams) error {
	_, err := q.db.ExecContext(ctx, deleteVote, arg.UserID, arg.SettingID)
	return err
}

const getAliasesByMaterial = `-- name: GetAliasesByMaterial :many
SELECT id, material_id, alias
FROM material_aliases
WHERE material_id = ?
ORDER BY alias
`

func (q *Queries) GetAliasesByMaterial(ctx context.Context, materialID int32) ([]MaterialAlias, error) {
	rows, err := q.db.QueryContext(ctx, getAliasesByMaterial, materialID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MaterialAlias
	for rows.Next() {
		var i MaterialAlias
		if err := rows.Scan(&i.ID, &i.MaterialID, &i.Alias); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllBrands = `-- name: GetAllBrands :many

SELECT id, name, slug
FROM machine_brands
ORDER BY name
`

// =====================
// MACHINE BRANDS
// =====================
func (q *Queries) GetAllBrands(ctx context.Context) ([]MachineBrand, error) {
	rows, err := q.db.QueryContext(ctx, getAllBrands)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MachineBrand
	for rows.Next() {
		var i MachineBrand
		if err := rows.Scan(&i.ID, &i.Name, &i.Slug); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCategories = `-- name: GetAllCategories :many

SELECT id, name
FROM material_categories
ORDER BY name
`

// =====================
// MATERIAL CATEGORIES
// =====================
func (q *Queries) GetAllCategories(ctx context.Context) ([]MaterialCategory, error) {
	rows, err := q.db.QueryContext(ctx, getAllCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MaterialCategory
	for rows.Next() {
		var i MaterialCategory
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllMaterials = `-- name: GetAllMaterials :many

SELECT m.id, m.category_id, m.name, m.slug,
       c.name as category_name
FROM materials m
JOIN material_categories c ON m.category_id = c.id
ORDER BY c.name, m.name
`

type GetAllMaterialsRow struct {
	ID           int32
	CategoryID   int32
	Name         string
	Slug         string
	CategoryName string
}

// =====================
// MATERIALS
// =====================
func (q *Queries) GetAllMaterials(ctx context.Context) ([]GetAllMaterialsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllMaterials)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllMaterialsRow
	for rows.Next() {
		var i GetAllMaterialsRow
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllModels = `-- name: GetAllModels :many
SELECT m.id, m.brand_id, m.name, m.laser_type, m.wattage, m.slug,
       b.name as brand_name
FROM machine_models m
JOIN machine_brands b ON m.brand_id = b.id
ORDER BY b.name, m.name
`

type GetAllModelsRow struct {
	ID        int32
	BrandID   int32
	Name      string
	LaserType MachineModelsLaserType
	Wattage   int32
	Slug      string
	BrandName string
}

func (q *Queries) GetAllModels(ctx context.Context) ([]GetAllModelsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllModels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllModelsRow
	for rows.Next() {
		var i GetAllModelsRow
		if err := rows.Scan(
			&i.ID,
			&i.BrandID,
			&i.Name,
			&i.LaserType,
			&i.Wattage,
			&i.Slug,
			&i.BrandName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllOperations = `-- name: GetAllOperations :many

SELECT id, name
FROM operations
ORDER BY name
`

// =====================
// OPERATIONS
// =====================
func (q *Queries) GetAllOperations(ctx context.Context) ([]Operation, error) {
	rows, err := q.db.QueryContext(ctx, getAllOperations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Operation
	for rows.Next() {
		var i Operation
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBrandByID = `-- name: GetBrandByID :one
SELECT id, name, slug
FROM machine_brands
WHERE id = ?
`

func (q *Queries) GetBrandByID(ctx context.Context, id int32) (MachineBrand, error) {
	row := q.db.QueryRowContext(ctx, getBrandByID, id)
	var i MachineBrand
	err := row.Scan(&i.ID, &i.Name, &i.Slug)
	return i, err
}

const getMaterialByID = `-- name: GetMaterialByID :one
SELECT m.id, m.category_id, m.name, m.slug,
       c.name as category_name
FROM materials m
JOIN material_categories c ON m.category_id = c.id
WHERE m.id = ?
`

type GetMaterialByIDRow struct {
	ID           int32
	CategoryID   int32
	Name         string
	Slug         string
	CategoryName string
}

func (q *Queries) GetMaterialByID(ctx context.Context, id int32) (GetMaterialByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getMaterialByID, id)
	var i GetMaterialByIDRow
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.CategoryName,
	)
	return i, err
}

const getMaterialsByCategory = `-- name: GetMaterialsByCategory :many
SELECT id, category_id, name, slug
FROM materials
WHERE category_id = ?
ORDER BY name
`

func (q *Queries) GetMaterialsByCategory(ctx context.Context, categoryID int32) ([]Material, error) {
	rows, err := q.db.QueryContext(ctx, getMaterialsByCategory, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Material
	for rows.Next() {
		var i Material
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModelByID = `-- name: GetModelByID :one
SELECT id, brand_id, name, laser_type, wattage, slug
FROM machine_models
WHERE id = ?
`

func (q *Queries) GetModelByID(ctx context.Context, id int32) (MachineModel, error) {
	row := q.db.QueryRowContext(ctx, getModelByID, id)
	var i MachineModel
	err := row.Scan(
		&i.ID,
		&i.BrandID,
		&i.Name,
		&i.LaserType,
		&i.Wattage,
		&i.Slug,
	)
	return i, err
}

const getModelsByBrand = `-- name: GetModelsByBrand :many

SELECT id, brand_id, name, laser_type, wattage, slug
FROM machine_models
WHERE brand_id = ?
ORDER BY name
`

// =====================
// MACHINE MODELS
// =====================
func (q *Queries) GetModelsByBrand(ctx context.Context, brandID int32) ([]MachineModel, error) {
	rows, err := q.db.QueryContext(ctx, getModelsByBrand, brandID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MachineModel
	for rows.Next() {
		var i MachineModel
		if err := rows.Scan(
			&i.ID,
			&i.BrandID,
			&i.Name,
			&i.LaserType,
			&i.Wattage,
			&i.Slug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSettingByID = `-- name: GetSettingByID :one

SELECT s.id, s.user_id, s.machine_model_id, s.material_id, s.operation_id,
       s.power, s.speed, s.passes, s.frequency, s.dpi, s.notes,
       s.created_at, s.updated_at,
       u.username, u.display_name,
       mm.name as model_name, mb.name as brand_name,
       mat.name as material_name, mc.name as category_name,
       op.name as operation_name,
       COALESCE(SUM(v.value), 0) as vote_score,
       COUNT(v.id) as vote_count
FROM settings s
JOIN users u ON s.user_id = u.id
JOIN machine_models mm ON s.machine_model_id = mm.id
JOIN machine_brands mb ON mm.brand_id = mb.id
JOIN materials mat ON s.material_id = mat.id
JOIN material_categories mc ON mat.category_id = mc.id
JOIN operations op ON s.operation_id = op.id
LEFT JOIN votes v ON v.setting_id = s.id
WHERE s.id = ?
GROUP BY s.id, s.user_id, s.machine_model_id, s.material_id, s.operation_id,
         s.power, s.speed, s.passes, s.frequency, s.dpi, s.notes,
         s.created_at, s.updated_at,
         u.username, u.display_name,
         mm.name, mb.name, mat.name, mc.name, op.name
`

type GetSettingByIDRow struct {
	ID             int32
	UserID         int32
	MachineModelID int32
	MaterialID     int32
	OperationID    int32
	Power          int32
	Speed          int32
	Passes         int32
	Frequency      sql.NullInt32
	Dpi            sql.NullInt32
	Notes          sql.NullString
	CreatedAt      sql.NullTime
	UpdatedAt      sql.NullTime
	Username       string
	DisplayName    sql.NullString
	ModelName      string
	BrandName      string
	MaterialName   string
	CategoryName   string
	OperationName  string
	VoteScore      interface{}
	VoteCount      int64
}

// =====================
// SETTINGS
// =====================
func (q *Queries) GetSettingByID(ctx context.Context, id int32) (GetSettingByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getSettingByID, id)
	var i GetSettingByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MachineModelID,
		&i.MaterialID,
		&i.OperationID,
		&i.Power,
		&i.Speed,
		&i.Passes,
		&i.Frequency,
		&i.Dpi,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Username,
		&i.DisplayName,
		&i.ModelName,
		&i.BrandName,
		&i.MaterialName,
		&i.CategoryName,
		&i.OperationName,
		&i.VoteScore,
		&i.VoteCount,
	)
	return i, err
}

const getTopSettings = `-- name: GetTopSettings :many
SELECT s.id, s.user_id, s.machine_model_id, s.material_id, s.operation_id,
       s.power, s.speed, s.passes, s.frequency, s.dpi, s.notes,
       s.created_at, s.updated_at,
       u.username, u.display_name,
       mm.name as model_name, mb.name as brand_name,
       mat.name as material_name, mc.name as category_name,
       op.name as operation_name,
       COALESCE(SUM(v.value), 0) as vote_score,
       COUNT(v.id) as vote_count
FROM settings s
JOIN users u ON s.user_id = u.id
JOIN machine_models mm ON s.machine_model_id = mm.id
JOIN machine_brands mb ON mm.brand_id = mb.id
JOIN materials mat ON s.material_id = mat.id
JOIN material_categories mc ON mat.category_id = mc.id
JOIN operations op ON s.operation_id = op.id
LEFT JOIN votes v ON v.setting_id = s.id
GROUP BY s.id, s.user_id, s.machine_model_id, s.material_id, s.operation_id,
         s.power, s.speed, s.passes, s.frequency, s.dpi, s.notes,
         s.created_at, s.updated_at,
         u.username, u.display_name,
         mm.name, mb.name, mat.name, mc.name, op.name
ORDER BY vote_score DESC
LIMIT 20
`

type GetTopSettingsRow struct {
	ID             int32
	UserID         int32
	MachineModelID int32
	MaterialID     int32
	OperationID    int32
	Power          int32
	Speed          int32
	Passes         int32
	Frequency      sql.NullInt32
	Dpi            sql.NullInt32
	Notes          sql.NullString
	CreatedAt      sql.NullTime
	UpdatedAt      sql.NullTime
	Username       string
	DisplayName    sql.NullString
	ModelName      string
	BrandName      string
	MaterialName   string
	CategoryName   string
	OperationName  string
	VoteScore      interface{}
	VoteCount      int64
}

func (q *Queries) GetTopSettings(ctx context.Context) ([]GetTopSettingsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopSettings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopSettingsRow
	for rows.Next() {
		var i GetTopSettingsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MachineModelID,
			&i.MaterialID,
			&i.OperationID,
			&i.Power,
			&i.Speed,
			&i.Passes,
			&i.Frequency,
			&i.Dpi,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
			&i.DisplayName,
			&i.ModelName,
			&i.BrandName,
			&i.MaterialName,
			&i.CategoryName,
			&i.OperationName,
			&i.VoteScore,
			&i.VoteCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, email, password_hash, display_name, created_at
FROM users
WHERE email = ?
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.DisplayName,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one

SELECT id, username, email, password_hash, display_name, created_at
FROM users
WHERE id = ?
`

// =====================
// USERS
// =====================
func (q *Queries) GetUserByID(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.DisplayName,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, email, password_hash, display_name, created_at
FROM users
WHERE username = ?
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.DisplayName,
		&i.CreatedAt,
	)
	return i, err
}

const getUserSettings = `-- name: GetUserSettings :many
SELECT s.id, s.user_id, s.machine_model_id, s.material_id, s.operation_id,
       s.power, s.speed, s.passes, s.frequency, s.dpi, s.notes,
       s.created_at, s.updated_at,
       mm.name as model_name, mb.name as brand_name,
       mat.name as material_name, mc.name as category_name,
       op.name as operation_name,
       COALESCE(SUM(v.value), 0) as vote_score,
       COUNT(v.id) as vote_count
FROM settings s
JOIN machine_models mm ON s.machine_model_id = mm.id
JOIN machine_brands mb ON mm.brand_id = mb.id
JOIN materials mat ON s.material_id = mat.id
JOIN material_categories mc ON mat.category_id = mc.id
JOIN operations op ON s.operation_id = op.id
LEFT JOIN votes v ON v.setting_id = s.id
WHERE s.user_id = ?
GROUP BY s.id, s.user_id, s.machine_model_id, s.material_id, s.operation_id,
         s.power, s.speed, s.passes, s.frequency, s.dpi, s.notes,
         s.created_at, s.updated_at,
         mm.name, mb.name, mat.name, mc.name, op.name
ORDER BY s.created_at DESC
`

type GetUserSettingsRow struct {
	ID             int32
	UserID         int32
	MachineModelID int32
	MaterialID     int32
	OperationID    int32
	Power          int32
	Speed          int32
	Passes         int32
	Frequency      sql.NullInt32
	Dpi            sql.NullInt32
	Notes          sql.NullString
	CreatedAt      sql.NullTime
	UpdatedAt      sql.NullTime
	ModelName      string
	BrandName      string
	MaterialName   string
	CategoryName   string
	OperationName  string
	VoteScore      interface{}
	VoteCount      int64
}

func (q *Queries) GetUserSettings(ctx context.Context, userID int32) ([]GetUserSettingsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserSettings, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserSettingsRow
	for rows.Next() {
		var i GetUserSettingsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MachineModelID,
			&i.MaterialID,
			&i.OperationID,
			&i.Power,
			&i.Speed,
			&i.Passes,
			&i.Frequency,
			&i.Dpi,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ModelName,
			&i.BrandName,
			&i.MaterialName,
			&i.CategoryName,
			&i.OperationName,
			&i.VoteScore,
			&i.VoteCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserVoteForSetting = `-- name: GetUserVoteForSetting :one

SELECT id, user_id, setting_id, value, created_at
FROM votes
WHERE user_id = ? AND setting_id = ?
`

type GetUserVoteForSettingParams struct {
	UserID    int32
	SettingID int32
}

// =====================
// VOTES
// =====================
func (q *Queries) GetUserVoteForSetting(ctx context.Context, arg GetUserVoteForSettingParams) (Vote, error) {
	row := q.db.QueryRowContext(ctx, getUserVoteForSetting, arg.UserID, arg.SettingID)
	var i Vote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SettingID,
		&i.Value,
		&i.CreatedAt,
	)
	return i, err
}

const getVoteScore = `-- name: GetVoteScore :one
SELECT COALESCE(SUM(value), 0) as score, COUNT(id) as total
FROM votes
WHERE setting_id = ?
`

type GetVoteScoreRow struct {
	Score interface{}
	Total int64
}

func (q *Queries) GetVoteScore(ctx context.Context, settingID int32) (GetVoteScoreRow, error) {
	row := q.db.QueryRowContext(ctx, getVoteScore, settingID)
	var i GetVoteScoreRow
	err := row.Scan(&i.Score, &i.Total)
	return i, err
}

const searchMaterials = `-- name: SearchMaterials :many
SELECT m.id, m.category_id, m.name, m.slug,
       c.name as category_name
FROM materials m
JOIN material_categories c ON m.category_id = c.id
WHERE m.name LIKE CONCAT('%', ?, '%')
   OR m.slug LIKE CONCAT('%', ?, '%')
ORDER BY m.name
LIMIT 20
`

type SearchMaterialsParams struct {
	CONCAT   interface{}
	CONCAT_2 interface{}
}

type SearchMaterialsRow struct {
	ID           int32
	CategoryID   int32
	Name         string
	Slug         string
	CategoryName string
}

func (q *Queries) SearchMaterials(ctx context.Context, arg SearchMaterialsParams) ([]SearchMaterialsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchMaterials, arg.CONCAT, arg.CONCAT_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchMaterialsRow
	for rows.Next() {
		var i SearchMaterialsRow
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSettings = `-- name: SearchSettings :many
SELECT s.id, s.user_id, s.machine_model_id, s.material_id, s.operation_id,
       s.power, s.speed, s.passes, s.frequency, s.dpi, s.notes,
       s.created_at, s.updated_at,
       u.username, u.display_name,
       mm.name as model_name, mb.name as brand_name,
       mat.name as material_name, mc.name as category_name,
       op.name as operation_name,
       COALESCE(SUM(v.value), 0) as vote_score,
       COUNT(v.id) as vote_count
FROM settings s
JOIN users u ON s.user_id = u.id
JOIN machine_models mm ON s.machine_model_id = mm.id
JOIN machine_brands mb ON mm.brand_id = mb.id
JOIN materials mat ON s.material_id = mat.id
JOIN material_categories mc ON mat.category_id = mc.id
JOIN operations op ON s.operation_id = op.id
LEFT JOIN votes v ON v.setting_id = s.id
WHERE (? IS NULL OR s.machine_model_id = ?)
  AND (? IS NULL OR s.material_id = ?)
  AND (? IS NULL OR s.operation_id = ?)
GROUP BY s.id, s.user_id, s.machine_model_id, s.material_id, s.operation_id,
         s.power, s.speed, s.passes, s.frequency, s.dpi, s.notes,
         s.created_at, s.updated_at,
         u.username, u.display_name,
         mm.name, mb.name, mat.name, mc.name, op.name
ORDER BY vote_score DESC, s.created_at DESC
LIMIT 50
`

type SearchSettingsParams struct {
	MachineModelID sql.NullInt32
	MaterialID     sql.NullInt32
	OperationID    sql.NullInt32
}

type SearchSettingsRow struct {
	ID             int32
	UserID         int32
	MachineModelID int32
	MaterialID     int32
	OperationID    int32
	Power          int32
	Speed          int32
	Passes         int32
	Frequency      sql.NullInt32
	Dpi            sql.NullInt32
	Notes          sql.NullString
	CreatedAt      sql.NullTime
	UpdatedAt      sql.NullTime
	Username       string
	DisplayName    sql.NullString
	ModelName      string
	BrandName      string
	MaterialName   string
	CategoryName   string
	OperationName  string
	VoteScore      interface{}
	VoteCount      int64
}

func (q *Queries) SearchSettings(ctx context.Context, arg SearchSettingsParams) ([]SearchSettingsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchSettings,
		arg.MachineModelID,
		arg.MachineModelID,
		arg.MaterialID,
		arg.MaterialID,
		arg.OperationID,
		arg.OperationID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchSettingsRow
	for rows.Next() {
		var i SearchSettingsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MachineModelID,
			&i.MaterialID,
			&i.OperationID,
			&i.Power,
			&i.Speed,
			&i.Passes,
			&i.Frequency,
			&i.Dpi,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
			&i.DisplayName,
			&i.ModelName,
			&i.BrandName,
			&i.MaterialName,
			&i.CategoryName,
			&i.OperationName,
			&i.VoteScore,
			&i.VoteCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSetting = `-- name: UpdateSetting :exec
UPDATE settings
SET power = ?, speed = ?, passes = ?, frequency = ?, dpi = ?, notes = ?
WHERE id = ? AND user_id = ?
`

type UpdateSettingParams struct {
	Power     int32
	Speed     int32
	Passes    int32
	Frequency sql.NullInt32
	Dpi       sql.NullInt32
	Notes     sql.NullString
	ID        int32
	UserID    int32
}

func (q *Queries) UpdateSetting(ctx context.Context, arg UpdateSettingParams) error {
	_, err := q.db.ExecContext(ctx, updateSetting,
		arg.Power,
		arg.Speed,
		arg.Passes,
		arg.Frequency,
		arg.Dpi,
		arg.Notes,
		arg.ID,
		arg.UserID,
	)
	return err
}

const upsertVote = `-- name: UpsertVote :exec
INSERT INTO votes (user_id, setting_id, value)
VALUES (?, ?, ?)
ON DUPLICATE KEY UPDATE value = VALUES(value)
`

type UpsertVoteParams struct {
	UserID    int32
	SettingID int32
	Value     int8
}

func (q *Queries) UpsertVote(ctx context.Context, arg UpsertVoteParams) error {
	_, err := q.db.ExecContext(ctx, upsertVote, arg.UserID, arg.SettingID, arg.Value)
	return err
}
